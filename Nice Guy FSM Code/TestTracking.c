#pragma config(Sensor, dgtl1,  leftDriveEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightDriveEncoder, sensorQuadEncoder)
#pragma config(Motor,  port1,           rightClaw,     tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           rightBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightFront,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightTop,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightLift,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           leftLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftFront,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftTop,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           leftBack,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          leftClaw,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Y Cable the left lift and right lift*/


//leftDrive1,leftDrive2,
//Gyro
/*#include "Robot.h"
#include "AutonFunctions.h"
#include "Enums.h"
#include "EnumsFunctions.h"*/
//#include "Vector2.h"
//moves robot to random coordinates'
void move();
task main()
{
	/*Initialize(Bot,leftDriveEnc, rightDriveEnc);
	startTask(UpdatePosition);*/
	while(true)
	{
		move();
	}
	//test movement with random points
	/*while(true)
	{
	Move(rand() % 50 + 20, rand() % 50 + 20);
	Stop();
	Move(0, 0);
	Stop();
	}*/

	//FSM
	/*	States state = Start;
	while(true)
	{
	switch(state)
	{
	case Start:
	state = IdleRobot;
	break;

	case IdleRobot:
	state = IdleRobotState(state);
	break;

	case FindObj:
	state = FindObjState(state);
	break;

	case GoToObj:
	state =	GoToObjState(state);
	break;

	case GrabObj:
	state =GrabObjState(state);
	break;

	case UpdateMap:
	state =UpdateMapState(state);
	break;

	case GoToFence:
	state =GoToFenceState(state);
	break;

	case Score:
	state =ScoreState(state);
	break;

	}
	}*/
}

void move()
{
	if(abs(vexRT[Ch2]) > 10)
	{
		motor[leftBack] = vexRT[Ch2];
		motor[leftFront] = vexRT[Ch2];
		motor[leftTop] = vexRT[Ch2];
	}
	else
	{
		motor[leftBack] = 0;
		motor[leftFront] = 0;
		motor[leftTop] = 0;
	}
	if(abs(vexRT[Ch3]) >10)
	{
		motor[rightBack] = vexRT[Ch3];
		motor[rightFront] = vexRT[Ch3];
		motor[rightTop] = vexRT[Ch3];
	}
	else
	{
		motor[rightBack] = 0;
		motor[rightFront] = 0;
		motor[rightTop] = 0;
	}
	if(vexRT[Btn6U])
	{
		motor[leftLift] = 127;
		motor[rightLift] = 127;
	}
	else if(vexRT[Btn6D])
	{
			motor[leftLift] = -127;
			motor[rightLift] = -127;
	}
	else
	{
		motor[leftLift] = 0;
		motor[rightLift] = 0;
	}

	if(vexRT[Btn5D])
	{
		motor[leftClaw] = -127;
		motor[rightClaw] = -127;
	}
	else if(vexRT[Btn5U])
	{
		motor[leftClaw] = 127;
		motor[rightClaw] = 127;
	}
	else
	{
		motor[leftClaw] = 0;
		motor[rightClaw] = 0;
	}

}
