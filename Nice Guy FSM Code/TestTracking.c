#pragma config(Sensor, dgtl1,  leftDriveEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightDriveEncoder, sensorQuadEncoder)
#pragma config(Motor,  port2,           rightBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightFront,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightTop,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftFront,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           leftTop,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftBack,      tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//leftDrive1,leftDrive2,
//Gyro
/*#include "Robot.h"
#include "AutonFunctions.h"
#include "Enums.h"
#include "EnumsFunctions.h"*/
//#include "Vector2.h"
//moves robot to random coordinates'
void move();
task main()
{
	/*Initialize(Bot,leftDriveEnc, rightDriveEnc);
	startTask(UpdatePosition);*/
	while(true)
	{
	move();
	}
	//test movement with random points
	/*while(true)
	{
	Move(rand() % 50 + 20, rand() % 50 + 20);
	Stop();
	Move(0, 0);
	Stop();
	}*/

	//FSM
/*	States state = Start;
	while(true)
	{
		switch(state)
		{
		case Start:
			state = IdleRobot;
			break;

		case IdleRobot:
			state = IdleRobotState(state);
			break;

		case FindObj:
			state = FindObjState(state);
			break;

		case GoToObj:
		state =	GoToObjState(state);
			break;

		case GrabObj:
			state =GrabObjState(state);
			break;

		case UpdateMap:
			state =UpdateMapState(state);
			break;

		case GoToFence:
			state =GoToFenceState(state);
			break;

		case Score:
			state =ScoreState(state);
			break;

		}
	}*/
}

void move()
{
		if(abs(vexRT[Ch3]) > 10)
		{
			motor[leftBack] = vexRT[Ch3];
			motor[leftFront] = vexRT[Ch3];
			motor[leftTop] = vexRT[Ch3];
		}
		else
		{
			motor[leftBack] = 0;
		motor[leftFront] = 0;
		motor[leftTop] = 0;
		}
		if(abs(vexRT[Ch2]) >10)
		{
		motor[rightBack] = vexRT[Ch2];
		motor[rightFront] = vexRT[Ch2];
		motor[rightTop] = vexRT[Ch2];
		}
		else
		{
			motor[rightBack] = 0;
			motor[rightFront] = 0;
			motor[rightTop] = 0;
		}

}
