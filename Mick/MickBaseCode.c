#pragma config(Sensor, in1,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, in8,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftDriveEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  clawPort,       sensorDigitalOut)
#pragma config(Sensor, dgtl11, rightDriveEncoder, sensorQuadEncoder)
#pragma config(Motor,  port1,           leftLift2,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftDriveBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftDriveCenter, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           leftDriveFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           leftLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightLift,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rightDriveBack, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           rightDriveCenter, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rightDriveFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          rightLift2,    tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)

bool clawPosition = false;
//0-open
//1-close

int auton = 0;
//0-auton
//1-skills

#include "Vex_Competition_Includes.c"
#include "MickDriverControl.h"
#include "MickAutonControl.h"
//#include "UART.h"


void ProgSkills();
void AutonomousRun();

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	liftPotentiometer.minValue = 245;
	liftPotentiometer.maxValue = 270;

	clawPotentiometer.minValue = 28;
	clawPotentiometer.maxValue = 15;
}

task autonomous()
{
	if(auton == 0)
	{
		AutonomousRun();
	}
	else
	{
		ProgSkills();
	}
}

void ProgSkills()
{
	clearAll(actOnSensors);
	startTask(UpdateSensors);

	//open to unlock claw
	startTask(OpenClaw);
	wait1Msec(250);
	stopTask(OpenClaw);
	wait1Msec(250);
	startTask(CloseClawSlight);
	wait1Msec(500);
	stopTask(CloseClawSlight);
	startTask(HighLift);
	wait1Msec(1000);
	stopTask(HighLift);
	CloseClaw();
	MoveForward(540);
	ReleasePayload();
	MoveBackward(-540);

	CloseClaw();
	MoveForward(540);
	ReleasePayload();
	startTask(LowLift);
	MoveBackward(-600);
	//Start with cube
	MoveForward(160);
	//TurnLeft(100);
	TurnGyro(-800);
	stopTask(LowLift);
	MoveForward(310);


	//move forward and grab cube
	CloseClaw();
	startTask(HighLift);
	SetDrive(0);
	wait1Msec(1000);
	TurnGyro(500);
	//TurnRight(80);

	//move forward and release the cube
	stopTask(HighLift);
	MoveForward(400);
	startTask(HighLift);
	ReleasePayload();
	stopTask(HighLift);
	//Move back and turn while lowering lift
	startTask(LowLift);
	MoveBackward(-200);
	stopTask(LowLift);
	wait1Msec(1000);
	TurnGyro(-900);
	wait1Msec(500);

	//Turn to opposite side
	MoveForward(400);
	CloseClaw();
	startTask(HighLift);
	TurnGyro(1000);
	wait1Msec(500);
	MoveForward(320);
	stopTask(HighLift);
	startTask(OpenClaw);
	wait1Msec(1000);

	SetLift(0);
	SetDrive(0);
	SetClaw(0);


}


void AutonomousRun()
{
	clearAll(actOnSensors);
	startTask(UpdateSensors);

	//open to unlock claw
	startTask(OpenClaw);
	wait1Msec(250);
	stopTask(OpenClaw);
	wait1Msec(250);
	startTask(CloseClawSlight);
	wait1Msec(500);
	stopTask(CloseClawSlight);

	/*
	wait1Msec(500);
	stopTask(StarLift);
	MoveBackward(-240);
	wait1Msec(500);
	startTask(LowLift);
	wait1Msec(500);
	TurnGyro(-700);
	stopTask(LowLift);
	MoveForward(200);
	*/
	//Start with cube
	MoveForward(100);
	//TurnLeft(100);
	TurnGyro(-800);
	MoveForward(310);


	//move forward and grab cube
	CloseClaw();
	startTask(HighLift);
	SetDrive(0);
	wait1Msec(1000);
	TurnGyro(500);
	//TurnRight(80);

	//move forward and release the cube
	stopTask(HighLift);
	MoveForward(400);
	//startTask(HighLift);
	ReleasePayload();
	//stopTask(HighLift);
	SetLift(0);
	//Move back and turn while lowering lift
	MoveBackward(-100);
	SetDrive(0);
	wait1Msec(1000);
	TurnGyro(-1500);
	wait1Msec(500);
	startTask(LowLift);
	wait1Msec(1000);

	//Turn to opposite side
	MoveForward(150);
	stopTask(LowLift);
	CloseClaw();
	startTask(HighLift);
	TurnGyro(1400);
	wait1Msec(500);
	MoveForward(320);
	stopTask(HighLift);
	startTask(OpenClaw);
	wait1Msec(1000);

	SetLift(0);
	SetDrive(0);
	SetClaw(0);
}


task usercontrol()
{
	while (true)
	{
		Drive();
		Lift();
		Claw();
	}
}
